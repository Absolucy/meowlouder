/* automatically generated by rust-bindgen 0.70.1 */

#![allow(
	non_camel_case_types,
	non_snake_case,
	non_upper_case_globals,
	rustdoc::broken_intra_doc_links
)]

pub type opus_int32 = ::std::os::raw::c_int;
pub type opus_uint32 = ::std::os::raw::c_uint;
pub type opus_int16 = ::std::os::raw::c_short;
pub type opus_uint16 = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusEncoder {
	_unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusDecoder {
	_unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusDREDDecoder {
	_unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusDRED {
	_unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusRepacketizer {
	_unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusMSEncoder {
	_unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusMSDecoder {
	_unused: [u8; 0],
}
pub const OPUS_OK: u32 = 0;
pub const OPUS_BAD_ARG: i32 = -1;
pub const OPUS_BUFFER_TOO_SMALL: i32 = -2;
pub const OPUS_INTERNAL_ERROR: i32 = -3;
pub const OPUS_INVALID_PACKET: i32 = -4;
pub const OPUS_UNIMPLEMENTED: i32 = -5;
pub const OPUS_INVALID_STATE: i32 = -6;
pub const OPUS_ALLOC_FAIL: i32 = -7;
pub const OPUS_SET_APPLICATION_REQUEST: u32 = 4000;
pub const OPUS_GET_APPLICATION_REQUEST: u32 = 4001;
pub const OPUS_SET_BITRATE_REQUEST: u32 = 4002;
pub const OPUS_GET_BITRATE_REQUEST: u32 = 4003;
pub const OPUS_SET_MAX_BANDWIDTH_REQUEST: u32 = 4004;
pub const OPUS_GET_MAX_BANDWIDTH_REQUEST: u32 = 4005;
pub const OPUS_SET_VBR_REQUEST: u32 = 4006;
pub const OPUS_GET_VBR_REQUEST: u32 = 4007;
pub const OPUS_SET_BANDWIDTH_REQUEST: u32 = 4008;
pub const OPUS_GET_BANDWIDTH_REQUEST: u32 = 4009;
pub const OPUS_SET_COMPLEXITY_REQUEST: u32 = 4010;
pub const OPUS_GET_COMPLEXITY_REQUEST: u32 = 4011;
pub const OPUS_SET_INBAND_FEC_REQUEST: u32 = 4012;
pub const OPUS_GET_INBAND_FEC_REQUEST: u32 = 4013;
pub const OPUS_SET_PACKET_LOSS_PERC_REQUEST: u32 = 4014;
pub const OPUS_GET_PACKET_LOSS_PERC_REQUEST: u32 = 4015;
pub const OPUS_SET_DTX_REQUEST: u32 = 4016;
pub const OPUS_GET_DTX_REQUEST: u32 = 4017;
pub const OPUS_SET_VBR_CONSTRAINT_REQUEST: u32 = 4020;
pub const OPUS_GET_VBR_CONSTRAINT_REQUEST: u32 = 4021;
pub const OPUS_SET_FORCE_CHANNELS_REQUEST: u32 = 4022;
pub const OPUS_GET_FORCE_CHANNELS_REQUEST: u32 = 4023;
pub const OPUS_SET_SIGNAL_REQUEST: u32 = 4024;
pub const OPUS_GET_SIGNAL_REQUEST: u32 = 4025;
pub const OPUS_GET_LOOKAHEAD_REQUEST: u32 = 4027;
pub const OPUS_GET_SAMPLE_RATE_REQUEST: u32 = 4029;
pub const OPUS_GET_FINAL_RANGE_REQUEST: u32 = 4031;
pub const OPUS_GET_PITCH_REQUEST: u32 = 4033;
pub const OPUS_SET_GAIN_REQUEST: u32 = 4034;
pub const OPUS_GET_GAIN_REQUEST: u32 = 4045;
pub const OPUS_SET_LSB_DEPTH_REQUEST: u32 = 4036;
pub const OPUS_GET_LSB_DEPTH_REQUEST: u32 = 4037;
pub const OPUS_GET_LAST_PACKET_DURATION_REQUEST: u32 = 4039;
pub const OPUS_SET_EXPERT_FRAME_DURATION_REQUEST: u32 = 4040;
pub const OPUS_GET_EXPERT_FRAME_DURATION_REQUEST: u32 = 4041;
pub const OPUS_SET_PREDICTION_DISABLED_REQUEST: u32 = 4042;
pub const OPUS_GET_PREDICTION_DISABLED_REQUEST: u32 = 4043;
pub const OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST: u32 = 4046;
pub const OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST: u32 = 4047;
pub const OPUS_GET_IN_DTX_REQUEST: u32 = 4049;
pub const OPUS_SET_DRED_DURATION_REQUEST: u32 = 4050;
pub const OPUS_GET_DRED_DURATION_REQUEST: u32 = 4051;
pub const OPUS_SET_DNN_BLOB_REQUEST: u32 = 4052;
pub const OPUS_AUTO: i32 = -1000;
pub const OPUS_BITRATE_MAX: i32 = -1;
pub const OPUS_APPLICATION_VOIP: u32 = 2048;
pub const OPUS_APPLICATION_AUDIO: u32 = 2049;
pub const OPUS_APPLICATION_RESTRICTED_LOWDELAY: u32 = 2051;
pub const OPUS_SIGNAL_VOICE: u32 = 3001;
pub const OPUS_SIGNAL_MUSIC: u32 = 3002;
pub const OPUS_BANDWIDTH_NARROWBAND: u32 = 1101;
pub const OPUS_BANDWIDTH_MEDIUMBAND: u32 = 1102;
pub const OPUS_BANDWIDTH_WIDEBAND: u32 = 1103;
pub const OPUS_BANDWIDTH_SUPERWIDEBAND: u32 = 1104;
pub const OPUS_BANDWIDTH_FULLBAND: u32 = 1105;
pub const OPUS_FRAMESIZE_ARG: u32 = 5000;
pub const OPUS_FRAMESIZE_2_5_MS: u32 = 5001;
pub const OPUS_FRAMESIZE_5_MS: u32 = 5002;
pub const OPUS_FRAMESIZE_10_MS: u32 = 5003;
pub const OPUS_FRAMESIZE_20_MS: u32 = 5004;
pub const OPUS_FRAMESIZE_40_MS: u32 = 5005;
pub const OPUS_FRAMESIZE_60_MS: u32 = 5006;
pub const OPUS_FRAMESIZE_80_MS: u32 = 5007;
pub const OPUS_FRAMESIZE_100_MS: u32 = 5008;
pub const OPUS_FRAMESIZE_120_MS: u32 = 5009;
pub const OPUS_RESET_STATE: u32 = 4028;
pub const OPUS_MULTISTREAM_GET_ENCODER_STATE_REQUEST: u32 = 5120;
pub const OPUS_MULTISTREAM_GET_DECODER_STATE_REQUEST: u32 = 5122;
extern "C" {
	#[doc = "Converts an opus error code into a human readable string.\n\n # Arguments\n\n* `error` (direction in) - <tt>int</tt>: Error number\n # Returns\n\nError string"]
	pub fn opus_strerror(error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
	#[doc = "Gets the libopus version string.\n\n Applications may look for the substring \"-fixed\" in the version string to\n determine whether they have a fixed-point or floating-point build at\n runtime.\n\n # Returns\n\nVersion string"]
	pub fn opus_get_version_string() -> *const ::std::os::raw::c_char;
	#[doc = "Gets the size of an <code>OpusEncoder</code> structure.\n # Arguments\n\n* `channels` (direction in) - <tt>int</tt>: Number of channels.\n This must be 1 or 2.\n # Returns\n\nThe size in bytes."]
	pub fn opus_encoder_get_size(channels: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
	#[doc = "Allocates and initializes an encoder state.\n There are three coding modes:\n\n OPUS_APPLICATION_VOIP gives best quality at a given bitrate for voice\n signals. It enhances the input signal by high-pass filtering and\n emphasizing formants and harmonics. Optionally it includes in-band\n forward error correction to protect against packet loss. Use this\n mode for typical VoIP applications. Because of the enhancement,\n even at high bitrates the output may sound different from the input.\n\n OPUS_APPLICATION_AUDIO gives best quality at a given bitrate for most\n non-voice signals like music. Use this mode for music and mixed\n (music/voice) content, broadcast, and applications requiring less\n than 15 ms of coding delay.\n\n OPUS_APPLICATION_RESTRICTED_LOWDELAY configures low-delay mode that\n disables the speech-optimized mode in exchange for slightly reduced delay.\n This mode can only be set on an newly initialized or freshly reset encoder\n because it changes the codec delay.\n\n This is useful when the caller knows that the speech-optimized modes will not be needed (use with caution).\n # Arguments\n\n* `[in]` - Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)\n This must be one of 8000, 12000, 16000,\n 24000, or 48000.\n * `[in]` - channels <tt>int</tt>: Number of channels (1 or 2) in input signal\n * `[in]` - application <tt>int</tt>: Coding mode (one of OPUS_APPLICATION_VOIP, OPUS_APPLICATION_AUDIO, or OPUS_APPLICATION_RESTRICTED_LOWDELAY)\n * `[out]` - error <tt>int*</tt>: opus_errorcodes\n > **Note:** Regardless of the sampling rate and number channels selected, the Opus encoder\n can switch to a lower audio bandwidth or number of channels if the bitrate\n selected is too low. This also means that it is safe to always use 48 kHz stereo input\n and let the encoder optimize the encoding."]
	pub fn opus_encoder_create(
		Fs: opus_int32,
		channels: ::std::os::raw::c_int,
		application: ::std::os::raw::c_int,
		error: *mut ::std::os::raw::c_int,
	) -> *mut OpusEncoder;
	#[doc = "Initializes a previously allocated encoder state\n The memory pointed to by st must be at least the size returned by opus_encoder_get_size().\n This is intended for applications which use their own allocator instead of malloc.\n [`opus_encoder_create(),opus_encoder_get_size()`]\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n # Arguments\n\n* `[in]` - st <tt>OpusEncoder*</tt>: Encoder state\n * `[in]` - Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)\n This must be one of 8000, 12000, 16000,\n 24000, or 48000.\n * `[in]` - channels <tt>int</tt>: Number of channels (1 or 2) in input signal\n * `[in]` - application <tt>int</tt>: Coding mode (one of OPUS_APPLICATION_VOIP, OPUS_APPLICATION_AUDIO, or OPUS_APPLICATION_RESTRICTED_LOWDELAY)\n # Returns\n\n* `#OPUS_OK` - Success or opus_errorcodes"]
	pub fn opus_encoder_init(
		st: *mut OpusEncoder,
		Fs: opus_int32,
		channels: ::std::os::raw::c_int,
		application: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
	#[doc = "Encodes an Opus frame.\n # Arguments\n\n* `[in]` - st <tt>OpusEncoder*</tt>: Encoder state\n * `[in]` - pcm <tt>opus_int16*</tt>: Input signal (interleaved if 2 channels). length is frame_size*channels*sizeof(opus_int16)\n * `[in]` - frame_size <tt>int</tt>: Number of samples per channel in the\n input signal.\n This must be an Opus frame size for\n the encoder's sampling rate.\n For example, at 48 kHz the permitted\n values are 120, 240, 480, 960, 1920,\n and 2880.\n Passing in a duration of less than\n 10 ms (480 samples at 48 kHz) will\n prevent the encoder from using the LPC\n or hybrid modes.\n * `[out]` - data <tt>unsigned char*</tt>: Output payload.\n This must contain storage for at\n least _max_data_bytes._\n * `[in]` - max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n memory for the output\n payload. This may be\n used to impose an upper limit on\n the instant bitrate, but should\n not be used as the only bitrate\n control. Use #OPUS_SET_BITRATE to\n control the bitrate.\n # Returns\n\nThe length of the encoded packet (in bytes) on success or a\n negative error code (see opus_errorcodes) on failure."]
	pub fn opus_encode(
		st: *mut OpusEncoder,
		pcm: *const opus_int16,
		frame_size: ::std::os::raw::c_int,
		data: *mut ::std::os::raw::c_uchar,
		max_data_bytes: opus_int32,
	) -> opus_int32;
	#[doc = "Encodes an Opus frame from floating point input.\n # Arguments\n\n* `[in]` - st <tt>OpusEncoder*</tt>: Encoder state\n * `[in]` - pcm <tt>float*</tt>: Input in float format (interleaved if 2 channels), with a normal range of +/-1.0.\n Samples with a range beyond +/-1.0 are supported but will\n be clipped by decoders using the integer API and should\n only be used if it is known that the far end supports\n extended dynamic range.\n length is frame_size*channels*sizeof(float)\n * `[in]` - frame_size <tt>int</tt>: Number of samples per channel in the\n input signal.\n This must be an Opus frame size for\n the encoder's sampling rate.\n For example, at 48 kHz the permitted\n values are 120, 240, 480, 960, 1920,\n and 2880.\n Passing in a duration of less than\n 10 ms (480 samples at 48 kHz) will\n prevent the encoder from using the LPC\n or hybrid modes.\n * `[out]` - data <tt>unsigned char*</tt>: Output payload.\n This must contain storage for at\n least _max_data_bytes._\n * `[in]` - max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n memory for the output\n payload. This may be\n used to impose an upper limit on\n the instant bitrate, but should\n not be used as the only bitrate\n control. Use #OPUS_SET_BITRATE to\n control the bitrate.\n # Returns\n\nThe length of the encoded packet (in bytes) on success or a\n negative error code (see opus_errorcodes) on failure."]
	pub fn opus_encode_float(
		st: *mut OpusEncoder,
		pcm: *const f32,
		frame_size: ::std::os::raw::c_int,
		data: *mut ::std::os::raw::c_uchar,
		max_data_bytes: opus_int32,
	) -> opus_int32;
	#[doc = "Frees an <code>OpusEncoder</code> allocated by opus_encoder_create().\n # Arguments\n\n* `st` (direction in) - <tt>OpusEncoder*</tt>: State to be freed."]
	pub fn opus_encoder_destroy(st: *mut OpusEncoder);
	#[doc = "Perform a CTL function on an Opus encoder.\n\n Generally the request and subsequent arguments are generated\n by a convenience macro.\n # Arguments\n\n* `st` - <tt>OpusEncoder*</tt>: Encoder state.\n * `request` - This and all remaining parameters should be replaced by one\n of the convenience macros in opus_genericctls or\n opus_encoderctls.\n [`opus_genericctls`]\n [`opus_encoderctls`]"]
	pub fn opus_encoder_ctl(
		st: *mut OpusEncoder,
		request: ::std::os::raw::c_int,
		...
	) -> ::std::os::raw::c_int;
	#[doc = "Gets the size of an <code>OpusDecoder</code> structure.\n # Arguments\n\n* `[in]` - channels <tt>int</tt>: Number of channels.\n This must be 1 or 2.\n # Returns\n\nThe size in bytes."]
	pub fn opus_decoder_get_size(channels: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
	#[doc = "Allocates and initializes a decoder state.\n # Arguments\n\n* `[in]` - Fs <tt>opus_int32</tt>: Sample rate to decode at (Hz).\n This must be one of 8000, 12000, 16000,\n 24000, or 48000.\n * `[in]` - channels <tt>int</tt>: Number of channels (1 or 2) to decode\n * `[out]` - error <tt>int*</tt>: #OPUS_OK Success or opus_errorcodes\n\n Internally Opus stores data at 48000 Hz, so that should be the default\n value for Fs. However, the decoder can efficiently decode to buffers\n at 8, 12, 16, and 24 kHz so if for some reason the caller cannot use\n data at the full sample rate, or knows the compressed data doesn't\n use the full frequency range, it can request decoding at a reduced\n rate. Likewise, the decoder is capable of filling in either mono or\n interleaved stereo pcm buffers, at the caller's request."]
	pub fn opus_decoder_create(
		Fs: opus_int32,
		channels: ::std::os::raw::c_int,
		error: *mut ::std::os::raw::c_int,
	) -> *mut OpusDecoder;
	#[doc = "Initializes a previously allocated decoder state.\n The state must be at least the size returned by opus_decoder_get_size().\n This is intended for applications which use their own allocator instead of malloc. [`opus_decoder_create,opus_decoder_get_size`]\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n # Arguments\n\n* `[in]` - st <tt>OpusDecoder*</tt>: Decoder state.\n * `[in]` - Fs <tt>opus_int32</tt>: Sampling rate to decode to (Hz).\n This must be one of 8000, 12000, 16000,\n 24000, or 48000.\n * `[in]` - channels <tt>int</tt>: Number of channels (1 or 2) to decode\n # Returns\n\n* `#OPUS_OK` - Success or opus_errorcodes"]
	pub fn opus_decoder_init(
		st: *mut OpusDecoder,
		Fs: opus_int32,
		channels: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
	#[doc = "Decode an Opus packet.\n # Arguments\n\n* `[in]` - st <tt>OpusDecoder*</tt>: Decoder state\n * `[in]` - data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss\n * `[in]` - len <tt>opus_int32</tt>: Number of bytes in payload*\n * `[out]` - pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length\n is frame_size*channels*sizeof(opus_int16)\n * `[in]` - frame_size Number of samples per channel of available space in _pcm._\n If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will\n not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),\n then frame_size needs to be exactly the duration of audio that is missing, otherwise the\n decoder will not be in the optimal state to decode the next incoming packet. For the PLC and\n FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.\n * `[in]` - decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be\n decoded. If no such data is available, the frame is decoded as if it were lost.\n # Returns\n\nNumber of decoded samples or opus_errorcodes"]
	pub fn opus_decode(
		st: *mut OpusDecoder,
		data: *const ::std::os::raw::c_uchar,
		len: opus_int32,
		pcm: *mut opus_int16,
		frame_size: ::std::os::raw::c_int,
		decode_fec: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
	#[doc = "Decode an Opus packet with floating point output.\n # Arguments\n\n* `[in]` - st <tt>OpusDecoder*</tt>: Decoder state\n * `[in]` - data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss\n * `[in]` - len <tt>opus_int32</tt>: Number of bytes in payload\n * `[out]` - pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length\n is frame_size*channels*sizeof(float)\n * `[in]` - frame_size Number of samples per channel of available space in _pcm._\n If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will\n not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),\n then frame_size needs to be exactly the duration of audio that is missing, otherwise the\n decoder will not be in the optimal state to decode the next incoming packet. For the PLC and\n FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.\n * `[in]` - decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be\n decoded. If no such data is available the frame is decoded as if it were lost.\n # Returns\n\nNumber of decoded samples or opus_errorcodes"]
	pub fn opus_decode_float(
		st: *mut OpusDecoder,
		data: *const ::std::os::raw::c_uchar,
		len: opus_int32,
		pcm: *mut f32,
		frame_size: ::std::os::raw::c_int,
		decode_fec: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
	#[doc = "Perform a CTL function on an Opus decoder.\n\n Generally the request and subsequent arguments are generated\n by a convenience macro.\n # Arguments\n\n* `st` - <tt>OpusDecoder*</tt>: Decoder state.\n * `request` - This and all remaining parameters should be replaced by one\n of the convenience macros in opus_genericctls or\n opus_decoderctls.\n [`opus_genericctls`]\n [`opus_decoderctls`]"]
	pub fn opus_decoder_ctl(
		st: *mut OpusDecoder,
		request: ::std::os::raw::c_int,
		...
	) -> ::std::os::raw::c_int;
	#[doc = "Frees an <code>OpusDecoder</code> allocated by opus_decoder_create().\n # Arguments\n\n* `st` (direction in) - <tt>OpusDecoder*</tt>: State to be freed."]
	pub fn opus_decoder_destroy(st: *mut OpusDecoder);
	#[doc = "Gets the size of an <code>OpusDREDDecoder</code> structure.\n # Returns\n\nThe size in bytes."]
	pub fn opus_dred_decoder_get_size() -> ::std::os::raw::c_int;
	#[doc = "Allocates and initializes an OpusDREDDecoder state.\n # Arguments\n\n* `[out]` - error <tt>int*</tt>: #OPUS_OK Success or opus_errorcodes"]
	pub fn opus_dred_decoder_create(error: *mut ::std::os::raw::c_int) -> *mut OpusDREDDecoder;
	#[doc = "Initializes an <code>OpusDREDDecoder</code> state.\n # Arguments\n\n* `dec` (direction in) - <tt>OpusDREDDecoder*</tt>: State to be initialized."]
	pub fn opus_dred_decoder_init(dec: *mut OpusDREDDecoder) -> ::std::os::raw::c_int;
	#[doc = "Frees an <code>OpusDREDDecoder</code> allocated by opus_dred_decoder_create().\n # Arguments\n\n* `dec` (direction in) - <tt>OpusDREDDecoder*</tt>: State to be freed."]
	pub fn opus_dred_decoder_destroy(dec: *mut OpusDREDDecoder);
	#[doc = "Perform a CTL function on an Opus DRED decoder.\n\n Generally the request and subsequent arguments are generated\n by a convenience macro.\n # Arguments\n\n* `dred_dec` - <tt>OpusDREDDecoder*</tt>: DRED Decoder state.\n * `request` - This and all remaining parameters should be replaced by one\n of the convenience macros in opus_genericctls or\n opus_decoderctls.\n [`opus_genericctls`]\n [`opus_decoderctls`]"]
	pub fn opus_dred_decoder_ctl(
		dred_dec: *mut OpusDREDDecoder,
		request: ::std::os::raw::c_int,
		...
	) -> ::std::os::raw::c_int;
	#[doc = "Gets the size of an <code>OpusDRED</code> structure.\n # Returns\n\nThe size in bytes."]
	pub fn opus_dred_get_size() -> ::std::os::raw::c_int;
	#[doc = "Allocates and initializes a DRED state.\n # Arguments\n\n* `[out]` - error <tt>int*</tt>: #OPUS_OK Success or opus_errorcodes"]
	pub fn opus_dred_alloc(error: *mut ::std::os::raw::c_int) -> *mut OpusDRED;
	#[doc = "Frees an <code>OpusDRED</code> allocated by opus_dred_create().\n # Arguments\n\n* `dec` (direction in) - <tt>OpusDRED*</tt>: State to be freed."]
	pub fn opus_dred_free(dec: *mut OpusDRED);
	#[doc = "Decode an Opus DRED packet.\n # Arguments\n\n* `[in]` - dred_dec <tt>OpusDRED*</tt>: DRED Decoder state\n * `[in]` - dred <tt>OpusDRED*</tt>: DRED state\n * `[in]` - data <tt>char*</tt>: Input payload\n * `[in]` - len <tt>opus_int32</tt>: Number of bytes in payload\n * `[in]` - max_dred_samples <tt>opus_int32</tt>: Maximum number of DRED samples that may be needed (if available in the packet).\n * `[in]` - sampling_rate <tt>opus_int32</tt>: Sampling rate used for max_dred_samples argument. Needs not match the actual sampling rate of the decoder.\n * `[out]` - dred_end <tt>opus_int32*</tt>: Number of non-encoded (silence) samples between the DRED timestamp and the last DRED sample.\n * `[in]` - defer_processing <tt>int</tt>: Flag (0 or 1). If set to one, the CPU-intensive part of the DRED decoding is deferred until opus_dred_process() is called.\n # Returns\n\nOffset (positive) of the first decoded DRED samples, zero if no DRED is present, or opus_errorcodes"]
	pub fn opus_dred_parse(
		dred_dec: *mut OpusDREDDecoder,
		dred: *mut OpusDRED,
		data: *const ::std::os::raw::c_uchar,
		len: opus_int32,
		max_dred_samples: opus_int32,
		sampling_rate: opus_int32,
		dred_end: *mut ::std::os::raw::c_int,
		defer_processing: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
	#[doc = "Finish decoding an Opus DRED packet. The function only needs to be called if opus_dred_parse() was called with defer_processing=1.\n The source and destination will often be the same DRED state.\n # Arguments\n\n* `[in]` - dred_dec <tt>OpusDRED*</tt>: DRED Decoder state\n * `[in]` - src <tt>OpusDRED*</tt>: Source DRED state to start the processing from.\n * `[out]` - dst <tt>OpusDRED*</tt>: Destination DRED state to store the updated state after processing.\n # Returns\n\nopus_errorcodes"]
	pub fn opus_dred_process(
		dred_dec: *mut OpusDREDDecoder,
		src: *const OpusDRED,
		dst: *mut OpusDRED,
	) -> ::std::os::raw::c_int;
	#[doc = "Decode audio from an Opus DRED packet with floating point output.\n # Arguments\n\n* `[in]` - st <tt>OpusDecoder*</tt>: Decoder state\n * `[in]` - dred <tt>OpusDRED*</tt>: DRED state\n * `[in]` - dred_offset <tt>opus_int32</tt>: position of the redundancy to decode (in samples before the beginning of the real audio data in the packet).\n * `[out]` - pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length\n is frame_size*channels*sizeof(opus_int16)\n * `[in]` - frame_size Number of samples per channel to decode in _pcm._\n frame_size <b>must</b> be a multiple of 2.5 ms.\n # Returns\n\nNumber of decoded samples or opus_errorcodes"]
	pub fn opus_decoder_dred_decode(
		st: *mut OpusDecoder,
		dred: *const OpusDRED,
		dred_offset: opus_int32,
		pcm: *mut opus_int16,
		frame_size: opus_int32,
	) -> ::std::os::raw::c_int;
	#[doc = "Decode audio from an Opus DRED packet with floating point output.\n # Arguments\n\n* `[in]` - st <tt>OpusDecoder*</tt>: Decoder state\n * `[in]` - dred <tt>OpusDRED*</tt>: DRED state\n * `[in]` - dred_offset <tt>opus_int32</tt>: position of the redundancy to decode (in samples before the beginning of the real audio data in the packet).\n * `[out]` - pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length\n is frame_size*channels*sizeof(float)\n * `[in]` - frame_size Number of samples per channel to decode in _pcm._\n frame_size <b>must</b> be a multiple of 2.5 ms.\n # Returns\n\nNumber of decoded samples or opus_errorcodes"]
	pub fn opus_decoder_dred_decode_float(
		st: *mut OpusDecoder,
		dred: *const OpusDRED,
		dred_offset: opus_int32,
		pcm: *mut f32,
		frame_size: opus_int32,
	) -> ::std::os::raw::c_int;
	#[doc = "Parse an opus packet into one or more frames.\n Opus_decode will perform this operation internally so most applications do\n not need to use this function.\n This function does not copy the frames, the returned pointers are pointers into\n the input packet.\n # Arguments\n\n* `[in]` - data <tt>char*</tt>: Opus packet to be parsed\n * `[in]` - len <tt>opus_int32</tt>: size of data\n * `[out]` - out_toc <tt>char*</tt>: TOC pointer\n * `[out]` - frames <tt>char*[48]</tt> encapsulated frames\n * `[out]` - size <tt>opus_int16[48]</tt> sizes of the encapsulated frames\n * `[out]` - payload_offset <tt>int*</tt>: returns the position of the payload within the packet (in bytes)\n # Returns\n\nnumber of frames"]
	pub fn opus_packet_parse(
		data: *const ::std::os::raw::c_uchar,
		len: opus_int32,
		out_toc: *mut ::std::os::raw::c_uchar,
		frames: *mut *const ::std::os::raw::c_uchar,
		size: *mut opus_int16,
		payload_offset: *mut ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
	#[doc = "Gets the bandwidth of an Opus packet.\n # Arguments\n\n* `[in]` - data <tt>char*</tt>: Opus packet\n # Returns\n\n* `OPUS_BANDWIDTH_NARROWBAND` - Narrowband (4kHz bandpass)\n * `OPUS_BANDWIDTH_MEDIUMBAND` - Mediumband (6kHz bandpass)\n * `OPUS_BANDWIDTH_WIDEBAND` - Wideband (8kHz bandpass)\n * `OPUS_BANDWIDTH_SUPERWIDEBAND` - Superwideband (12kHz bandpass)\n * `OPUS_BANDWIDTH_FULLBAND` - Fullband (20kHz bandpass)\n * `OPUS_INVALID_PACKET` - The compressed data passed is corrupted or of an unsupported type"]
	pub fn opus_packet_get_bandwidth(data: *const ::std::os::raw::c_uchar)
		-> ::std::os::raw::c_int;
	#[doc = "Gets the number of samples per frame from an Opus packet.\n # Arguments\n\n* `[in]` - data <tt>char*</tt>: Opus packet.\n This must contain at least one byte of\n data.\n * `[in]` - Fs <tt>opus_int32</tt>: Sampling rate in Hz.\n This must be a multiple of 400, or\n inaccurate results will be returned.\n # Returns\n\nNumber of samples per frame."]
	pub fn opus_packet_get_samples_per_frame(
		data: *const ::std::os::raw::c_uchar,
		Fs: opus_int32,
	) -> ::std::os::raw::c_int;
	#[doc = "Gets the number of channels from an Opus packet.\n # Arguments\n\n* `[in]` - data <tt>char*</tt>: Opus packet\n # Returns\n\nNumber of channels\n * `OPUS_INVALID_PACKET` - The compressed data passed is corrupted or of an unsupported type"]
	pub fn opus_packet_get_nb_channels(
		data: *const ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
	#[doc = "Gets the number of frames in an Opus packet.\n # Arguments\n\n* `[in]` - packet <tt>char*</tt>: Opus packet\n * `[in]` - len <tt>opus_int32</tt>: Length of packet\n # Returns\n\nNumber of frames\n * `OPUS_BAD_ARG` - Insufficient data was passed to the function\n * `OPUS_INVALID_PACKET` - The compressed data passed is corrupted or of an unsupported type"]
	pub fn opus_packet_get_nb_frames(
		packet: *const ::std::os::raw::c_uchar,
		len: opus_int32,
	) -> ::std::os::raw::c_int;
	#[doc = "Gets the number of samples of an Opus packet.\n # Arguments\n\n* `[in]` - packet <tt>char*</tt>: Opus packet\n * `[in]` - len <tt>opus_int32</tt>: Length of packet\n * `[in]` - Fs <tt>opus_int32</tt>: Sampling rate in Hz.\n This must be a multiple of 400, or\n inaccurate results will be returned.\n # Returns\n\nNumber of samples\n * `OPUS_BAD_ARG` - Insufficient data was passed to the function\n * `OPUS_INVALID_PACKET` - The compressed data passed is corrupted or of an unsupported type"]
	pub fn opus_packet_get_nb_samples(
		packet: *const ::std::os::raw::c_uchar,
		len: opus_int32,
		Fs: opus_int32,
	) -> ::std::os::raw::c_int;
	#[doc = "Checks whether an Opus packet has LBRR.\n # Arguments\n\n* `[in]` - packet <tt>char*</tt>: Opus packet\n * `[in]` - len <tt>opus_int32</tt>: Length of packet\n # Returns\n\n1 is LBRR is present, 0 otherwise\n * `OPUS_INVALID_PACKET` - The compressed data passed is corrupted or of an unsupported type"]
	pub fn opus_packet_has_lbrr(
		packet: *const ::std::os::raw::c_uchar,
		len: opus_int32,
	) -> ::std::os::raw::c_int;
	#[doc = "Gets the number of samples of an Opus packet.\n # Arguments\n\n* `[in]` - dec <tt>OpusDecoder*</tt>: Decoder state\n * `[in]` - packet <tt>char*</tt>: Opus packet\n * `[in]` - len <tt>opus_int32</tt>: Length of packet\n # Returns\n\nNumber of samples\n * `OPUS_BAD_ARG` - Insufficient data was passed to the function\n * `OPUS_INVALID_PACKET` - The compressed data passed is corrupted or of an unsupported type"]
	pub fn opus_decoder_get_nb_samples(
		dec: *const OpusDecoder,
		packet: *const ::std::os::raw::c_uchar,
		len: opus_int32,
	) -> ::std::os::raw::c_int;
	#[doc = "Applies soft-clipping to bring a float signal within the [-1,1] range. If\n the signal is already in that range, nothing is done. If there are values\n outside of [-1,1], then the signal is clipped as smoothly as possible to\n both fit in the range and avoid creating excessive distortion in the\n process.\n # Arguments\n\n* `[in,out]` - pcm <tt>float*</tt>: Input PCM and modified PCM\n * `[in]` - frame_size <tt>int</tt> Number of samples per channel to process\n * `[in]` - channels <tt>int</tt>: Number of channels\n * `[in,out]` - softclip_mem <tt>float*</tt>: State memory for the soft clipping process (one float per channel, initialized to zero)"]
	pub fn opus_pcm_soft_clip(
		pcm: *mut f32,
		frame_size: ::std::os::raw::c_int,
		channels: ::std::os::raw::c_int,
		softclip_mem: *mut f32,
	);
	#[doc = "Gets the size of an <code>OpusRepacketizer</code> structure.\n # Returns\n\nThe size in bytes."]
	pub fn opus_repacketizer_get_size() -> ::std::os::raw::c_int;
	#[doc = "(Re)initializes a previously allocated repacketizer state.\n The state must be at least the size returned by opus_repacketizer_get_size().\n This can be used for applications which use their own allocator instead of\n malloc().\n It must also be called to reset the queue of packets waiting to be\n repacketized, which is necessary if the maximum packet duration of 120 ms\n is reached or if you wish to submit packets with a different Opus\n configuration (coding mode, audio bandwidth, frame size, or channel count).\n Failure to do so will prevent a new packet from being added with\n opus_repacketizer_cat().\n [`opus_repacketizer_create`]\n [`opus_repacketizer_get_size`]\n [`opus_repacketizer_cat`]\n # Arguments\n\n* `rp` - <tt>OpusRepacketizer*</tt>: The repacketizer state to\n (re)initialize.\n # Returns\n\nA pointer to the same repacketizer state that was passed in."]
	pub fn opus_repacketizer_init(rp: *mut OpusRepacketizer) -> *mut OpusRepacketizer;
	#[doc = "Allocates memory and initializes the new repacketizer with\n opus_repacketizer_init()."]
	pub fn opus_repacketizer_create() -> *mut OpusRepacketizer;
	#[doc = "Frees an <code>OpusRepacketizer</code> allocated by\n opus_repacketizer_create().\n # Arguments\n\n* `rp` (direction in) - <tt>OpusRepacketizer*</tt>: State to be freed."]
	pub fn opus_repacketizer_destroy(rp: *mut OpusRepacketizer);
	#[doc = "Add a packet to the current repacketizer state.\n This packet must match the configuration of any packets already submitted\n for repacketization since the last call to opus_repacketizer_init().\n This means that it must have the same coding mode, audio bandwidth, frame\n size, and channel count.\n This can be checked in advance by examining the top 6 bits of the first\n byte of the packet, and ensuring they match the top 6 bits of the first\n byte of any previously submitted packet.\n The total duration of audio in the repacketizer state also must not exceed\n 120 ms, the maximum duration of a single packet, after adding this packet.\n\n The contents of the current repacketizer state can be extracted into new\n packets using opus_repacketizer_out() or opus_repacketizer_out_range().\n\n In order to add a packet with a different configuration or to add more\n audio beyond 120 ms, you must clear the repacketizer state by calling\n opus_repacketizer_init().\n If a packet is too large to add to the current repacketizer state, no part\n of it is added, even if it contains multiple frames, some of which might\n fit.\n If you wish to be able to add parts of such packets, you should first use\n another repacketizer to split the packet into pieces and add them\n individually.\n [`opus_repacketizer_out_range`]\n [`opus_repacketizer_out`]\n [`opus_repacketizer_init`]\n # Arguments\n\n* `rp` - <tt>OpusRepacketizer*</tt>: The repacketizer state to which to\n add the packet.\n * `data` (direction in) - <tt>const unsigned char*</tt>: The packet data.\n The application must ensure\n this pointer remains valid\n until the next call to\n opus_repacketizer_init() or\n opus_repacketizer_destroy().\n * `len` - <tt>opus_int32</tt>: The number of bytes in the packet data.\n # Returns\n\nAn error code indicating whether or not the operation succeeded.\n * `#OPUS_OK` - The packet's contents have been added to the repacketizer\n state.\n * `#OPUS_INVALID_PACKET` - The packet did not have a valid TOC sequence,\n the packet's TOC sequence was not compatible\n with previously submitted packets (because\n the coding mode, audio bandwidth, frame size,\n or channel count did not match), or adding\n this packet would increase the total amount of\n audio stored in the repacketizer state to more\n than 120 ms."]
	pub fn opus_repacketizer_cat(
		rp: *mut OpusRepacketizer,
		data: *const ::std::os::raw::c_uchar,
		len: opus_int32,
	) -> ::std::os::raw::c_int;
	#[doc = "Construct a new packet from data previously submitted to the repacketizer\n state via opus_repacketizer_cat().\n # Arguments\n\n* `rp` - <tt>OpusRepacketizer*</tt>: The repacketizer state from which to\n construct the new packet.\n * `begin` - <tt>int</tt>: The index of the first frame in the current\n repacketizer state to include in the output.\n * `end` - <tt>int</tt>: One past the index of the last frame in the\n current repacketizer state to include in the\n output.\n * `data` (direction out) - <tt>const unsigned char*</tt>: The buffer in which to\n store the output packet.\n * `maxlen` - <tt>opus_int32</tt>: The maximum number of bytes to store in\n the output buffer. In order to guarantee\n success, this should be at least\n <code>1276</code> for a single frame,\n or for multiple frames,\n <code>1277*(end-begin)</code>.\n However, <code>1*(end-begin)</code> plus\n the size of all packet data submitted to\n the repacketizer since the last call to\n opus_repacketizer_init() or\n opus_repacketizer_create() is also\n sufficient, and possibly much smaller.\n # Returns\n\nThe total size of the output packet on success, or an error code\n on failure.\n * `#OPUS_BAD_ARG` - <code>[begin,end)</code> was an invalid range of\n frames (begin < 0, begin >= end, or end >\n opus_repacketizer_get_nb_frames()).\n * `#OPUS_BUFFER_TOO_SMALL` - _maxlen_ was insufficient to contain the\n complete output packet."]
	pub fn opus_repacketizer_out_range(
		rp: *mut OpusRepacketizer,
		begin: ::std::os::raw::c_int,
		end: ::std::os::raw::c_int,
		data: *mut ::std::os::raw::c_uchar,
		maxlen: opus_int32,
	) -> opus_int32;
	#[doc = "Return the total number of frames contained in packet data submitted to\n the repacketizer state so far via opus_repacketizer_cat() since the last\n call to opus_repacketizer_init() or opus_repacketizer_create().\n This defines the valid range of packets that can be extracted with\n opus_repacketizer_out_range() or opus_repacketizer_out().\n # Arguments\n\n* `rp` - <tt>OpusRepacketizer*</tt>: The repacketizer state containing the\n frames.\n # Returns\n\nThe total number of frames contained in the packet data submitted\n to the repacketizer state."]
	pub fn opus_repacketizer_get_nb_frames(rp: *mut OpusRepacketizer) -> ::std::os::raw::c_int;
	#[doc = "Construct a new packet from data previously submitted to the repacketizer\n state via opus_repacketizer_cat().\n This is a convenience routine that returns all the data submitted so far\n in a single packet.\n It is equivalent to calling\n opus_repacketizer_out_range(rp, 0, opus_repacketizer_get_nb_frames(rp),\n data, maxlen)\n # Arguments\n\n* `rp` - <tt>OpusRepacketizer*</tt>: The repacketizer state from which to\n construct the new packet.\n * `data` (direction out) - <tt>const unsigned char*</tt>: The buffer in which to\n store the output packet.\n * `maxlen` - <tt>opus_int32</tt>: The maximum number of bytes to store in\n the output buffer. In order to guarantee\n success, this should be at least\n <code>1277*opus_repacketizer_get_nb_frames(rp)</code>.\n However,\n <code>1*opus_repacketizer_get_nb_frames(rp)</code>\n plus the size of all packet data\n submitted to the repacketizer since the\n last call to opus_repacketizer_init() or\n opus_repacketizer_create() is also\n sufficient, and possibly much smaller.\n # Returns\n\nThe total size of the output packet on success, or an error code\n on failure.\n * `#OPUS_BUFFER_TOO_SMALL` - _maxlen_ was insufficient to contain the\n complete output packet."]
	pub fn opus_repacketizer_out(
		rp: *mut OpusRepacketizer,
		data: *mut ::std::os::raw::c_uchar,
		maxlen: opus_int32,
	) -> opus_int32;
	#[doc = "Pads a given Opus packet to a larger size (possibly changing the TOC sequence).\n # Arguments\n\n* `data` (direction in, out) - <tt>const unsigned char*</tt>: The buffer containing the\n packet to pad.\n * `len` - <tt>opus_int32</tt>: The size of the packet.\n This must be at least 1.\n * `new_len` - <tt>opus_int32</tt>: The desired size of the packet after padding.\n This must be at least as large as len.\n # Returns\n\nan error code\n * `#OPUS_OK` - _on_ success.\n * `#OPUS_BAD_ARG` - _len_ was less than 1 or new_len was less than len.\n * `#OPUS_INVALID_PACKET` - _data_ did not contain a valid Opus packet."]
	pub fn opus_packet_pad(
		data: *mut ::std::os::raw::c_uchar,
		len: opus_int32,
		new_len: opus_int32,
	) -> ::std::os::raw::c_int;
	#[doc = "Remove all padding from a given Opus packet and rewrite the TOC sequence to\n minimize space usage.\n # Arguments\n\n* `data` (direction in, out) - <tt>const unsigned char*</tt>: The buffer containing the\n packet to strip.\n * `len` - <tt>opus_int32</tt>: The size of the packet.\n This must be at least 1.\n # Returns\n\nThe new size of the output packet on success, or an error code\n on failure.\n * `#OPUS_BAD_ARG` - _len_ was less than 1.\n * `#OPUS_INVALID_PACKET` - _data_ did not contain a valid Opus packet."]
	pub fn opus_packet_unpad(data: *mut ::std::os::raw::c_uchar, len: opus_int32) -> opus_int32;
	#[doc = "Pads a given Opus multi-stream packet to a larger size (possibly changing the TOC sequence).\n # Arguments\n\n* `data` (direction in, out) - <tt>const unsigned char*</tt>: The buffer containing the\n packet to pad.\n * `len` - <tt>opus_int32</tt>: The size of the packet.\n This must be at least 1.\n * `new_len` - <tt>opus_int32</tt>: The desired size of the packet after padding.\n This must be at least 1.\n * `nb_streams` - <tt>opus_int32</tt>: The number of streams (not channels) in the packet.\n This must be at least as large as len.\n # Returns\n\nan error code\n * `#OPUS_OK` - _on_ success.\n * `#OPUS_BAD_ARG` - _len_ was less than 1.\n * `#OPUS_INVALID_PACKET` - _data_ did not contain a valid Opus packet."]
	pub fn opus_multistream_packet_pad(
		data: *mut ::std::os::raw::c_uchar,
		len: opus_int32,
		new_len: opus_int32,
		nb_streams: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
	#[doc = "Remove all padding from a given Opus multi-stream packet and rewrite the TOC sequence to\n minimize space usage.\n # Arguments\n\n* `data` (direction in, out) - <tt>const unsigned char*</tt>: The buffer containing the\n packet to strip.\n * `len` - <tt>opus_int32</tt>: The size of the packet.\n This must be at least 1.\n * `nb_streams` - <tt>opus_int32</tt>: The number of streams (not channels) in the packet.\n This must be at least 1.\n # Returns\n\nThe new size of the output packet on success, or an error code\n on failure.\n * `#OPUS_BAD_ARG` - _len_ was less than 1 or new_len was less than len.\n * `#OPUS_INVALID_PACKET` - _data_ did not contain a valid Opus packet."]
	pub fn opus_multistream_packet_unpad(
		data: *mut ::std::os::raw::c_uchar,
		len: opus_int32,
		nb_streams: ::std::os::raw::c_int,
	) -> opus_int32;
	#[doc = "Gets the size of an OpusMSEncoder structure.\n # Arguments\n\n* `streams` - <tt>int</tt>: The total number of streams to encode from the\n input.\n This must be no more than 255.\n * `coupled_streams` - <tt>int</tt>: Number of coupled (2 channel) streams\n to encode.\n This must be no larger than the total\n number of streams.\n Additionally, The total number of\n encoded channels (<code>streams +\n coupled_streams</code>) must be no\n more than 255.\n # Returns\n\nThe size in bytes on success, or a negative error code\n (see opus_errorcodes) on error."]
	pub fn opus_multistream_encoder_get_size(
		streams: ::std::os::raw::c_int,
		coupled_streams: ::std::os::raw::c_int,
	) -> opus_int32;
	pub fn opus_multistream_surround_encoder_get_size(
		channels: ::std::os::raw::c_int,
		mapping_family: ::std::os::raw::c_int,
	) -> opus_int32;
	#[doc = "Allocates and initializes a multistream encoder state.\n Call opus_multistream_encoder_destroy() to release\n this object when finished.\n # Arguments\n\n* `Fs` - <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).\n This must be one of 8000, 12000, 16000,\n 24000, or 48000.\n * `channels` - <tt>int</tt>: Number of channels in the input signal.\n This must be at most 255.\n It may be greater than the number of\n coded channels (<code>streams +\n coupled_streams</code>).\n * `streams` - <tt>int</tt>: The total number of streams to encode from the\n input.\n This must be no more than the number of channels.\n * `coupled_streams` - <tt>int</tt>: Number of coupled (2 channel) streams\n to encode.\n This must be no larger than the total\n number of streams.\n Additionally, The total number of\n encoded channels (<code>streams +\n coupled_streams</code>) must be no\n more than the number of input channels.\n * `mapping` (direction in) - <code>const unsigned char[channels]</code>: Mapping from\n encoded channels to input channels, as described in\n opus_multistream. As an extra constraint, the\n multistream encoder does not allow encoding coupled\n streams for which one channel is unused since this\n is never a good idea.\n * `application` - <tt>int</tt>: The target encoder application.\n This must be one of the following:\n <dl>\n <dt>#OPUS_APPLICATION_VOIP</dt>\n <dd>Process signal for improved speech intelligibility.</dd>\n <dt>#OPUS_APPLICATION_AUDIO</dt>\n <dd>Favor faithfulness to the original input.</dd>\n <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>\n <dd>Configure the minimum possible coding delay by disabling certain modes\n of operation.</dd>\n </dl>\n * `error` (direction out) - <tt>int *</tt>: Returns #OPUS_OK on success, or an error\n code (see opus_errorcodes) on\n failure."]
	pub fn opus_multistream_encoder_create(
		Fs: opus_int32,
		channels: ::std::os::raw::c_int,
		streams: ::std::os::raw::c_int,
		coupled_streams: ::std::os::raw::c_int,
		mapping: *const ::std::os::raw::c_uchar,
		application: ::std::os::raw::c_int,
		error: *mut ::std::os::raw::c_int,
	) -> *mut OpusMSEncoder;
	pub fn opus_multistream_surround_encoder_create(
		Fs: opus_int32,
		channels: ::std::os::raw::c_int,
		mapping_family: ::std::os::raw::c_int,
		streams: *mut ::std::os::raw::c_int,
		coupled_streams: *mut ::std::os::raw::c_int,
		mapping: *mut ::std::os::raw::c_uchar,
		application: ::std::os::raw::c_int,
		error: *mut ::std::os::raw::c_int,
	) -> *mut OpusMSEncoder;
	#[doc = "Initialize a previously allocated multistream encoder state.\n The memory pointed to by _st_ must be at least the size returned by\n opus_multistream_encoder_get_size().\n This is intended for applications which use their own allocator instead of\n malloc.\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n [`opus_multistream_encoder_create`]\n [`opus_multistream_encoder_get_size`]\n # Arguments\n\n* `st` - <tt>OpusMSEncoder*</tt>: Multistream encoder state to initialize.\n * `Fs` - <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).\n This must be one of 8000, 12000, 16000,\n 24000, or 48000.\n * `channels` - <tt>int</tt>: Number of channels in the input signal.\n This must be at most 255.\n It may be greater than the number of\n coded channels (<code>streams +\n coupled_streams</code>).\n * `streams` - <tt>int</tt>: The total number of streams to encode from the\n input.\n This must be no more than the number of channels.\n * `coupled_streams` - <tt>int</tt>: Number of coupled (2 channel) streams\n to encode.\n This must be no larger than the total\n number of streams.\n Additionally, The total number of\n encoded channels (<code>streams +\n coupled_streams</code>) must be no\n more than the number of input channels.\n * `mapping` (direction in) - <code>const unsigned char[channels]</code>: Mapping from\n encoded channels to input channels, as described in\n opus_multistream. As an extra constraint, the\n multistream encoder does not allow encoding coupled\n streams for which one channel is unused since this\n is never a good idea.\n * `application` - <tt>int</tt>: The target encoder application.\n This must be one of the following:\n <dl>\n <dt>#OPUS_APPLICATION_VOIP</dt>\n <dd>Process signal for improved speech intelligibility.</dd>\n <dt>#OPUS_APPLICATION_AUDIO</dt>\n <dd>Favor faithfulness to the original input.</dd>\n <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>\n <dd>Configure the minimum possible coding delay by disabling certain modes\n of operation.</dd>\n </dl>\n # Returns\n\n#OPUS_OK on success, or an error code (see opus_errorcodes)\n on failure."]
	pub fn opus_multistream_encoder_init(
		st: *mut OpusMSEncoder,
		Fs: opus_int32,
		channels: ::std::os::raw::c_int,
		streams: ::std::os::raw::c_int,
		coupled_streams: ::std::os::raw::c_int,
		mapping: *const ::std::os::raw::c_uchar,
		application: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
	pub fn opus_multistream_surround_encoder_init(
		st: *mut OpusMSEncoder,
		Fs: opus_int32,
		channels: ::std::os::raw::c_int,
		mapping_family: ::std::os::raw::c_int,
		streams: *mut ::std::os::raw::c_int,
		coupled_streams: *mut ::std::os::raw::c_int,
		mapping: *mut ::std::os::raw::c_uchar,
		application: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
	#[doc = "Encodes a multistream Opus frame.\n # Arguments\n\n* `st` - <tt>OpusMSEncoder*</tt>: Multistream encoder state.\n * `pcm` (direction in) - <tt>const opus_int16*</tt>: The input signal as interleaved\n samples.\n This must contain\n <code>frame_size*channels</code>\n samples.\n * `frame_size` - <tt>int</tt>: Number of samples per channel in the input\n signal.\n This must be an Opus frame size for the\n encoder's sampling rate.\n For example, at 48 kHz the permitted values\n are 120, 240, 480, 960, 1920, and 2880.\n Passing in a duration of less than 10 ms\n (480 samples at 48 kHz) will prevent the\n encoder from using the LPC or hybrid modes.\n * `data` (direction out) - <tt>unsigned char*</tt>: Output payload.\n This must contain storage for at\n least _max_data_bytes._\n * `[in]` - max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n memory for the output\n payload. This may be\n used to impose an upper limit on\n the instant bitrate, but should\n not be used as the only bitrate\n control. Use #OPUS_SET_BITRATE to\n control the bitrate.\n # Returns\n\nThe length of the encoded packet (in bytes) on success or a\n negative error code (see opus_errorcodes) on failure."]
	pub fn opus_multistream_encode(
		st: *mut OpusMSEncoder,
		pcm: *const opus_int16,
		frame_size: ::std::os::raw::c_int,
		data: *mut ::std::os::raw::c_uchar,
		max_data_bytes: opus_int32,
	) -> ::std::os::raw::c_int;
	#[doc = "Encodes a multistream Opus frame from floating point input.\n # Arguments\n\n* `st` - <tt>OpusMSEncoder*</tt>: Multistream encoder state.\n * `pcm` (direction in) - <tt>const float*</tt>: The input signal as interleaved\n samples with a normal range of\n +/-1.0.\n Samples with a range beyond +/-1.0\n are supported but will be clipped by\n decoders using the integer API and\n should only be used if it is known\n that the far end supports extended\n dynamic range.\n This must contain\n <code>frame_size*channels</code>\n samples.\n * `frame_size` - <tt>int</tt>: Number of samples per channel in the input\n signal.\n This must be an Opus frame size for the\n encoder's sampling rate.\n For example, at 48 kHz the permitted values\n are 120, 240, 480, 960, 1920, and 2880.\n Passing in a duration of less than 10 ms\n (480 samples at 48 kHz) will prevent the\n encoder from using the LPC or hybrid modes.\n * `data` (direction out) - <tt>unsigned char*</tt>: Output payload.\n This must contain storage for at\n least _max_data_bytes._\n * `[in]` - max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n memory for the output\n payload. This may be\n used to impose an upper limit on\n the instant bitrate, but should\n not be used as the only bitrate\n control. Use #OPUS_SET_BITRATE to\n control the bitrate.\n # Returns\n\nThe length of the encoded packet (in bytes) on success or a\n negative error code (see opus_errorcodes) on failure."]
	pub fn opus_multistream_encode_float(
		st: *mut OpusMSEncoder,
		pcm: *const f32,
		frame_size: ::std::os::raw::c_int,
		data: *mut ::std::os::raw::c_uchar,
		max_data_bytes: opus_int32,
	) -> ::std::os::raw::c_int;
	#[doc = "Frees an <code>OpusMSEncoder</code> allocated by\n opus_multistream_encoder_create().\n # Arguments\n\n* `st` - <tt>OpusMSEncoder*</tt>: Multistream encoder state to be freed."]
	pub fn opus_multistream_encoder_destroy(st: *mut OpusMSEncoder);
	#[doc = "Perform a CTL function on a multistream Opus encoder.\n\n Generally the request and subsequent arguments are generated by a\n convenience macro.\n # Arguments\n\n* `st` - <tt>OpusMSEncoder*</tt>: Multistream encoder state.\n * `request` - This and all remaining parameters should be replaced by one\n of the convenience macros in opus_genericctls,\n opus_encoderctls, or opus_multistream_ctls.\n [`opus_genericctls`]\n [`opus_encoderctls`]\n [`opus_multistream_ctls`]"]
	pub fn opus_multistream_encoder_ctl(
		st: *mut OpusMSEncoder,
		request: ::std::os::raw::c_int,
		...
	) -> ::std::os::raw::c_int;
	#[doc = "Gets the size of an <code>OpusMSDecoder</code> structure.\n # Arguments\n\n* `streams` - <tt>int</tt>: The total number of streams coded in the\n input.\n This must be no more than 255.\n * `coupled_streams` - <tt>int</tt>: Number streams to decode as coupled\n (2 channel) streams.\n This must be no larger than the total\n number of streams.\n Additionally, The total number of\n coded channels (<code>streams +\n coupled_streams</code>) must be no\n more than 255.\n # Returns\n\nThe size in bytes on success, or a negative error code\n (see opus_errorcodes) on error."]
	pub fn opus_multistream_decoder_get_size(
		streams: ::std::os::raw::c_int,
		coupled_streams: ::std::os::raw::c_int,
	) -> opus_int32;
	#[doc = "Allocates and initializes a multistream decoder state.\n Call opus_multistream_decoder_destroy() to release\n this object when finished.\n # Arguments\n\n* `Fs` - <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).\n This must be one of 8000, 12000, 16000,\n 24000, or 48000.\n * `channels` - <tt>int</tt>: Number of channels to output.\n This must be at most 255.\n It may be different from the number of coded\n channels (<code>streams +\n coupled_streams</code>).\n * `streams` - <tt>int</tt>: The total number of streams coded in the\n input.\n This must be no more than 255.\n * `coupled_streams` - <tt>int</tt>: Number of streams to decode as coupled\n (2 channel) streams.\n This must be no larger than the total\n number of streams.\n Additionally, The total number of\n coded channels (<code>streams +\n coupled_streams</code>) must be no\n more than 255.\n * `mapping` (direction in) - <code>const unsigned char[channels]</code>: Mapping from\n coded channels to output channels, as described in\n opus_multistream.\n * `error` (direction out) - <tt>int *</tt>: Returns #OPUS_OK on success, or an error\n code (see opus_errorcodes) on\n failure."]
	pub fn opus_multistream_decoder_create(
		Fs: opus_int32,
		channels: ::std::os::raw::c_int,
		streams: ::std::os::raw::c_int,
		coupled_streams: ::std::os::raw::c_int,
		mapping: *const ::std::os::raw::c_uchar,
		error: *mut ::std::os::raw::c_int,
	) -> *mut OpusMSDecoder;
	#[doc = "Intialize a previously allocated decoder state object.\n The memory pointed to by _st_ must be at least the size returned by\n opus_multistream_encoder_get_size().\n This is intended for applications which use their own allocator instead of\n malloc.\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n [`opus_multistream_decoder_create`]\n [`opus_multistream_deocder_get_size`]\n # Arguments\n\n* `st` - <tt>OpusMSEncoder*</tt>: Multistream encoder state to initialize.\n * `Fs` - <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).\n This must be one of 8000, 12000, 16000,\n 24000, or 48000.\n * `channels` - <tt>int</tt>: Number of channels to output.\n This must be at most 255.\n It may be different from the number of coded\n channels (<code>streams +\n coupled_streams</code>).\n * `streams` - <tt>int</tt>: The total number of streams coded in the\n input.\n This must be no more than 255.\n * `coupled_streams` - <tt>int</tt>: Number of streams to decode as coupled\n (2 channel) streams.\n This must be no larger than the total\n number of streams.\n Additionally, The total number of\n coded channels (<code>streams +\n coupled_streams</code>) must be no\n more than 255.\n * `mapping` (direction in) - <code>const unsigned char[channels]</code>: Mapping from\n coded channels to output channels, as described in\n opus_multistream.\n # Returns\n\n#OPUS_OK on success, or an error code (see opus_errorcodes)\n on failure."]
	pub fn opus_multistream_decoder_init(
		st: *mut OpusMSDecoder,
		Fs: opus_int32,
		channels: ::std::os::raw::c_int,
		streams: ::std::os::raw::c_int,
		coupled_streams: ::std::os::raw::c_int,
		mapping: *const ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
	#[doc = "Decode a multistream Opus packet.\n # Arguments\n\n* `st` - <tt>OpusMSDecoder*</tt>: Multistream decoder state.\n * `data` (direction in) - <tt>const unsigned char*</tt>: Input payload.\n Use a <code>NULL</code>\n pointer to indicate packet\n loss.\n * `len` - <tt>opus_int32</tt>: Number of bytes in payload.\n * `pcm` (direction out) - <tt>opus_int16*</tt>: Output signal, with interleaved\n samples.\n This must contain room for\n <code>frame_size*channels</code>\n samples.\n * `frame_size` - <tt>int</tt>: The number of samples per channel of\n available space in _pcm._\n If this is less than the maximum packet duration\n (120 ms; 5760 for 48kHz), this function will not be capable\n of decoding some packets. In the case of PLC (data==NULL)\n or FEC (decode_fec=1), then frame_size needs to be exactly\n the duration of audio that is missing, otherwise the\n decoder will not be in the optimal state to decode the\n next incoming packet. For the PLC and FEC cases, frame_size\n <b>must</b> be a multiple of 2.5 ms.\n * `decode_fec` - <tt>int</tt>: Flag (0 or 1) to request that any in-band\n forward error correction data be decoded.\n If no such data is available, the frame is\n decoded as if it were lost.\n # Returns\n\nNumber of samples decoded on success or a negative error code\n (see opus_errorcodes) on failure."]
	pub fn opus_multistream_decode(
		st: *mut OpusMSDecoder,
		data: *const ::std::os::raw::c_uchar,
		len: opus_int32,
		pcm: *mut opus_int16,
		frame_size: ::std::os::raw::c_int,
		decode_fec: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
	#[doc = "Decode a multistream Opus packet with floating point output.\n # Arguments\n\n* `st` - <tt>OpusMSDecoder*</tt>: Multistream decoder state.\n * `data` (direction in) - <tt>const unsigned char*</tt>: Input payload.\n Use a <code>NULL</code>\n pointer to indicate packet\n loss.\n * `len` - <tt>opus_int32</tt>: Number of bytes in payload.\n * `pcm` (direction out) - <tt>opus_int16*</tt>: Output signal, with interleaved\n samples.\n This must contain room for\n <code>frame_size*channels</code>\n samples.\n * `frame_size` - <tt>int</tt>: The number of samples per channel of\n available space in _pcm._\n If this is less than the maximum packet duration\n (120 ms; 5760 for 48kHz), this function will not be capable\n of decoding some packets. In the case of PLC (data==NULL)\n or FEC (decode_fec=1), then frame_size needs to be exactly\n the duration of audio that is missing, otherwise the\n decoder will not be in the optimal state to decode the\n next incoming packet. For the PLC and FEC cases, frame_size\n <b>must</b> be a multiple of 2.5 ms.\n * `decode_fec` - <tt>int</tt>: Flag (0 or 1) to request that any in-band\n forward error correction data be decoded.\n If no such data is available, the frame is\n decoded as if it were lost.\n # Returns\n\nNumber of samples decoded on success or a negative error code\n (see opus_errorcodes) on failure."]
	pub fn opus_multistream_decode_float(
		st: *mut OpusMSDecoder,
		data: *const ::std::os::raw::c_uchar,
		len: opus_int32,
		pcm: *mut f32,
		frame_size: ::std::os::raw::c_int,
		decode_fec: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
	#[doc = "Perform a CTL function on a multistream Opus decoder.\n\n Generally the request and subsequent arguments are generated by a\n convenience macro.\n # Arguments\n\n* `st` - <tt>OpusMSDecoder*</tt>: Multistream decoder state.\n * `request` - This and all remaining parameters should be replaced by one\n of the convenience macros in opus_genericctls,\n opus_decoderctls, or opus_multistream_ctls.\n [`opus_genericctls`]\n [`opus_decoderctls`]\n [`opus_multistream_ctls`]"]
	pub fn opus_multistream_decoder_ctl(
		st: *mut OpusMSDecoder,
		request: ::std::os::raw::c_int,
		...
	) -> ::std::os::raw::c_int;
	#[doc = "Frees an <code>OpusMSDecoder</code> allocated by\n opus_multistream_decoder_create().\n # Arguments\n\n* `st` - <tt>OpusMSDecoder</tt>: Multistream decoder state to be freed."]
	pub fn opus_multistream_decoder_destroy(st: *mut OpusMSDecoder);
}
